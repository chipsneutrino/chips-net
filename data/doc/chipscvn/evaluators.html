<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>chipscvn.evaluators API documentation</title>
<meta name="description" content="Evaluator classes for testing the trained models â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>chipscvn.evaluators</code></h1>
</header>
<section id="section-intro">
<p>Evaluator classes for testing the trained models</p>
<p>This module contains all the evaluation classes used to test the
trained models on test data to determine their performance. All are
derived from the BaseEvaluator class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#34;&#34;&#34;
Evaluator classes for testing the trained models

This module contains all the evaluation classes used to test the
trained models on test data to determine their performance. All are
derived from the BaseEvaluator class.
&#34;&#34;&#34;

import time

import pandas as pd
from tensorflow.keras import Model
import ROOT
from root_numpy import fill_hist

import chipscvn.config
import chipscvn.data as data
import chipscvn.utils as utils


class BaseEvaluator(object):

    &#34;&#34;&#34;
    Base evaluator class which all implementations derive from.
    &#34;&#34;&#34;

    def __init__(self, config):
        &#34;&#34;&#34;
        Initialise the BasicTrainer.

        Args:
            config (dotmap.DotMap): DotMap Configuration namespace
        &#34;&#34;&#34;
        self.config = config
        self.init_evaluator()

    def init_evaluator(self):
        &#34;&#34;&#34;
        Initialise the evaluator, overide in derived evaluator class.
        &#34;&#34;&#34;
        raise NotImplementedError

    def run(self):
        &#34;&#34;&#34;
        Run the evaluator, overide in derived evaluator class.
        &#34;&#34;&#34;
        raise NotImplementedError


class CombinedEvaluator(BaseEvaluator):

    &#34;&#34;&#34;
    Combined Cosmic and Beam classification model evaluation.
    &#34;&#34;&#34;

    def __init__(self, config):
        &#34;&#34;&#34;
        Initialise the CombinedEvaluator.

        Args:
            config (dotmap.DotMap): DotMap Configuration namespace
        &#34;&#34;&#34;
        super().__init__(config)

    def init_evaluator(self):
        &#34;&#34;&#34;
        Initialise the evaluator, setup models and evaluation data.
        &#34;&#34;&#34;
        # Get the cosmic classification model and load the most recent weights
        c_config = self.config
        c_config.model = self.config.models.cosmic
        c_config.exp.experiment_dir = self.config.models.cosmic.dir
        c_config.exp.name = self.config.models.cosmic.path
        chipscvn.config.setup_dirs(c_config, False)
        self.c_model = utils.get_model(c_config)
        self.c_model.load()

        # Get the beam classification model and load the most recent weights
        b_config = self.config
        b_config.model = self.config.models.beam
        b_config.exp.experiment_dir = self.config.models.beam.dir
        b_config.exp.name = self.config.models.beam.path
        chipscvn.config.setup_dirs(b_config, False)
        self.b_model = utils.get_model(b_config)
        self.b_model.load()

        # Get the test dataset
        data_loader = data.DataLoader(self.config)
        self.data = data_loader.test_data()

        # Fully combined category names
        self.comb_cat_names = [&#39;Nuel-CC&#39;, &#39;Numu-CC&#39;, &#39;NC&#39;, &#39;Cosmic&#39;]

    def run(self):
        &#34;&#34;&#34;
        Run the full evaluation.
        &#34;&#34;&#34;
        print(&#39;--- Running Evaluation ---\n&#39;)

        start_time = time.time()  # Time how long it takes

        self.run_inference()  # Get model outputs for test data
        self.parse_outputs()  # Parse the outputs into other quantities
        self.calculate_weights()  # Calculate the weights to apply categorically
        self.calculate_cuts()  # Calculate different cuts to be applied

        print(&#39;--- Done (took %s seconds) ---\n&#39; % (time.time() - start_time))

    def run_inference(self):
        &#34;&#34;&#34;
        Get model outputs for test data.
        &#34;&#34;&#34;
        print(&#39;--- running inference...\n&#39;)

        events = {  # Create empty dict to hold all the event data
            &#39;t_nu&#39;: [], &#39;t_code&#39;: [], &#39;t_cat&#39;: [], &#39;t_cosmic_cat&#39;: [],
            &#39;t_full_cat&#39;: [], &#39;t_nu_nc_cat&#39;: [], &#39;t_nc_cat&#39;: [],
            &#39;t_vtxX&#39;: [], &#39;t_vtxY&#39;: [], &#39;t_vtxZ&#39;: [], &#39;t_vtxT&#39;: [], &#39;t_nuEnergy&#39;: [],
            &#39;t_p_pdgs&#39;: [], &#39;t_p_energies&#39;: [], &#39;t_p_dirTheta&#39;: [], &#39;t_p_dirPhi&#39;: [],
            &#39;r_raw_num_hits&#39;: [], &#39;r_filtered_num_hits&#39;: [], &#39;r_num_hough_rings&#39;: [],
            &#39;r_raw_total_digi_q&#39;: [], &#39;r_filtered_total_digi_q&#39;: [],
            &#39;r_first_ring_height&#39;: [], &#39;r_last_ring_height&#39;: [],
            &#39;r_vtxX&#39;: [], &#39;r_vtxY&#39;: [], &#39;r_vtxZ&#39;: [], &#39;r_vtxT&#39;: [],
            &#39;r_dirTheta&#39;: [], &#39;r_dirPhi&#39;: [],
            &#39;c_out&#39;: [], &#39;b_out&#39;: [], &#39;c_dense&#39;: [], &#39;b_dense&#39;: []
        }

        images = self.config.data.img_size[2]
        if self.config.data.stack:
            images = 1
        for i in range(images):
            events[(&#39;image_&#39; + str(i))] = []

        c_dense_model = Model(  # Model to ouput cosmic model dense layer
            inputs=self.c_model.model.input,
            outputs=self.c_model.model.get_layer(&#39;dense_final&#39;).output
        )

        b_dense_model = Model(  # Model to ouput beam model dense layer
            inputs=self.b_model.model.input,
            outputs=self.b_model.model.get_layer(&#39;dense_final&#39;).output
        )

        for x, y in self.data:  # Run prediction on individual batches
            for name, array in list(x.items()):  # Fill events dict with &#39;inputs&#39;
                if name in events.keys():
                    events[name].extend(array.numpy())

            for name, array in list(y.items()):  # Fill events dict with &#39;labels&#39;
                if name in events.keys():
                    events[name].extend(array.numpy())

            events[&#39;c_out&#39;].extend(self.c_model.model.predict(x))
            events[&#39;b_out&#39;].extend(self.b_model.model.predict(x))
            events[&#39;c_dense&#39;].extend(c_dense_model.predict(x))
            events[&#39;b_dense&#39;].extend(b_dense_model.predict(x))

        self.events = pd.DataFrame.from_dict(events)  # Convert dict to pandas dataframe
        self.events = self.events.sample(frac=1).reset_index(drop=True)  # Shuffle the dataframe

    def parse_outputs(self):
        &#34;&#34;&#34;
        Parse the outputs into other quantities.
        &#34;&#34;&#34;
        print(&#39;--- parsing outputs...\n&#39;)

        # Parse outputs into easier to use pandas columns including combined outputs
        self.events.c_out = self.events.c_out.map(lambda x: x[0])
        for i in range(self.b_model.categories):
            self.events[(&#39;b_out_&#39; + str(i))] = self.events.b_out.map(lambda x: x[i])

        self.events[&#39;scores&#39;] = self.events.apply(self.b_model.combine_outputs, axis=1)
        self.events[&#39;nuel_score&#39;] = self.events.scores.map(lambda x: x[0])
        self.events[&#39;numu_score&#39;] = self.events.scores.map(lambda x: x[1])
        self.events[&#39;nc_score&#39;] = self.events.scores.map(lambda x: x[2])
        self.events.drop(&#39;b_out&#39;, axis=1, inplace=True)
        self.events.drop(&#39;scores&#39;, axis=1, inplace=True)

    def calculate_weights(self):
        &#34;&#34;&#34;
        Calculate the weights to apply categorically.
        &#34;&#34;&#34;
        print(&#39;--- calculating weights...\n&#39;)

        tot_nuel = self.events[(self.events.t_nu == 0) &amp;
                               (self.events.t_cosmic_cat == 0)].shape[0]
        tot_numu = self.events[(self.events.t_nu == 1) &amp;
                               (self.events.t_cosmic_cat == 0)].shape[0]
        tot_cosmic = self.events[self.events.t_cosmic_cat == 1].shape[0]
        print(&#34;Total-&gt; Nuel: {}, Numu: {}, Cosmic: {}\n&#34;.format(tot_nuel, tot_numu, tot_cosmic))

        self.nuel_weight = (1.0/tot_nuel)*(self.config.eval.weights.nuel *
                                           self.config.eval.weights.total)
        self.numu_weight = (1.0/tot_numu)*(self.config.eval.weights.numu *
                                           self.config.eval.weights.total)
        self.cosmic_weight = (1.0/tot_cosmic)*(self.config.eval.weights.cosmic *
                                               self.config.eval.weights.total)

        print(&#39;Weights-&gt; Nuel:{0:.4f}, Numu:{1:.4f}, Cosmic:{2:.4f}\n&#39;.format(
            self.nuel_weight, self.numu_weight, self.cosmic_weight)
        )

        self.events[&#39;weight&#39;] = self.events.apply(self.add_weight, axis=1)

    def add_weight(self, event):
        &#34;&#34;&#34;
        Add the correct weight to each event.

        Args:
            event (dict): Pandas event(row) dict
        Returns:
            float: Weight to use for event
        &#34;&#34;&#34;
        if event.t_nu == 0 and event.t_cosmic_cat == 0:
            return self.nuel_weight
        elif event.t_nu == 1 and event.t_cosmic_cat == 0:
            return self.numu_weight
        elif event.t_cosmic_cat == 1:
            return self.cosmic_weight
        else:
            raise NotImplementedError

    def calculate_cuts(self):
        &#34;&#34;&#34;
        Calculate different cuts to be applied.
        &#34;&#34;&#34;
        print(&#39;--- calculating cuts...\n&#39;)

        self.events[&#39;base_cut&#39;] = self.events.apply(self.base_cut, axis=1)
        self.events[&#39;cosmic_cut&#39;] = self.events.apply(self.cosmic_cut, axis=1)

    def base_cut_summary(self):
        &#34;&#34;&#34;
        Print how each category is affected by the base_cut.
        &#34;&#34;&#34;
        print(&#34;Base Cut Summary...\n&#34;)
        for i in range(4):
            cat_events = self.events[self.events.t_full_cat == i]
            print(&#34;{}-&gt; Total {}, Survived: {}\n&#34;.format(
                self.comb_cat_names[i], cat_events.shape[0],
                cat_events[cat_events[&#39;base_cut&#39;] == 0].shape[0]/cat_events.shape[0]))

    def combined_cut_summary(self):
        &#34;&#34;&#34;
        Print how each category is affected by the base_cut + cosmic_cut.
        &#34;&#34;&#34;
        print(&#34;Base + Cosmic Cut Summary...\n&#34;)
        for i in range(4):
            cat_events = self.events[self.events.t_full_cat == i]
            print(&#34;{}-&gt; Total {}, Survived: {}\n&#34;.format(
                self.comb_cat_names[i], cat_events.shape[0], cat_events[
                    (cat_events.base_cut == 0) &amp;
                    (cat_events.cosmic_cut == 0)].shape[0]/cat_events.shape[0]))

    def base_cut(self, event):
        &#34;&#34;&#34;
        Calculate if the event should be cut due to activity.

        Args:
            event (dict): Pandas event(row) dict
        Returns:
            bool: cut or not?
        &#34;&#34;&#34;
        cut = ((event.r_raw_total_digi_q &lt;= self.config.eval.cuts.q) or
               (event.r_first_ring_height &lt;= self.config.eval.cuts.hough) or
               (event.r_dirTheta &lt;= -self.config.eval.cuts.theta) or
               (event.r_dirTheta &gt;= self.config.eval.cuts.theta) or
               (event.r_dirPhi &lt;= -self.config.eval.cuts.phi) or
               (event.r_dirPhi &gt;= self.config.eval.cuts.phi))
        return cut

    def cosmic_cut(self, event):
        &#34;&#34;&#34;
        Calculate if the event should be cut due to the cosmic network output.

        Args:
            event (dict): Pandas event(row) dict
        Returns:
            bool: cut or not?
        &#34;&#34;&#34;
        return (event.c_out &gt;= self.config.eval.cuts.cosmic)

    def cat_plot(self, parameter, bins, x_low, x_high, y_low, y_high, scale=&#39;norm&#39;,
                 base_cut=True, cosmic_cut=True):
        &#34;&#34;&#34;
        Make the histograms and legend for a parameter, split by true category.

        Args:
            parameter (str): Paramter to plot
            bins (int): How many x-bins to use
            x_low (float): Low x-range
            x_high (float): High x-range
            y_low (float): Low y-range
            y_high (float): High y-range
            scale (str): How to scale the histograms
            base_cut (bool): Apply to the base cut?
            cosmic_cut (bool): Apply the cosmic cut?
        Returns:
            tuple(List[ROOT.TH1F], ROOT.TLegend): (List of histograms, Plot legend)
        &#34;&#34;&#34;
        hists = []
        colours = [ROOT.kGreen, ROOT.kGreen+1, ROOT.kGreen+2, ROOT.kGreen+3,
                   ROOT.kBlue, ROOT.kBlue+1, ROOT.kBlue+2, ROOT.kBlue+3,
                   ROOT.kRed, ROOT.kRed+1, ROOT.kRed+2, ROOT.kRed+3,
                   ROOT.kOrange, ROOT.kOrange+1, ROOT.kOrange+2, ROOT.kOrange+3,
                   ROOT.kBlack]
        leg = ROOT.TLegend(0.65, 0.65, 0.80, 0.89, &#34;Event Type&#34;)
        entries = [&#34;EL-CC-QEL&#34;, &#34;EL-CC-RES&#34;, &#34;EL-CC-DIS&#34;, &#34;EL-CC-COH&#34;,
                   &#34;MU-CC-QEL&#34;, &#34;MU-CC-RES&#34;, &#34;MU-CC-DIS&#34;, &#34;MU-CC-COH&#34;,
                   &#34;EL-NC-QEL&#34;, &#34;EL-NC-RES&#34;, &#34;EL-NC-DIS&#34;, &#34;EL-NC-COH&#34;,
                   &#34;MU-NC-QEL&#34;, &#34;MU-NC-RES&#34;, &#34;MU-NC-DIS&#34;, &#34;MU-NC-COH&#34;,
                   &#34;Cosmic&#34;]
        for i in range(17):
            name = &#34;h_&#34; + parameter + &#34;_&#34; + entries[i]
            hist = ROOT.TH1F(name, parameter, bins, x_low, x_high)
            hist.SetLineColor(colours[i])
            hist.SetLineWidth(2)
            hist.GetXaxis().SetTitle(parameter)

            events = self.events[self.events[&#39;t_cat&#39;] == i]

            if base_cut:
                events = events[events.base_cut == 0]
            if cosmic_cut:
                events = events[events.cosmic_cut == 0]

            if scale == &#39;weight&#39;:
                fill_hist(hist, events[parameter].to_numpy(), events[&#39;weight&#39;].to_numpy())
            elif scale == &#39;norm&#39;:
                fill_hist(hist, events[parameter].to_numpy())
                if hist.GetEntries() &gt; 0:
                    hist.Scale(1.0/hist.GetEntries())
            elif scale == &#39;none&#39;:
                fill_hist(hist, events[parameter].to_numpy())
            else:
                raise NotImplementedError
            hists.append(hist)
            leg.AddEntry(hists[i], entries[i], &#34;PL&#34;)

        hists[0].GetYaxis().SetRangeUser(y_low, y_high)

        leg.SetTextSize(0.03)
        leg.SetTextFont(42)
        leg.SetBorderSize(0)

        return hists, leg

    def combined_cat_plot(self, parameter, bins, x_low, x_high, y_low, y_high, scale=&#39;norm&#39;,
                          base_cut=True, cosmic_cut=True):
        &#34;&#34;&#34;
        Make the histograms and legend for a parameter, split by combined category.

        Args:
            parameter (str): Paramter to plot
            bins (int): How many x-bins to use
            x_low (float): Low x-range
            x_high (float): High x-range
            y_low (float): Low y-range
            y_high (float): High y-range
            scale (str): How to scale the histograms
            base_cut (bool): Apply to the base cut?
            cosmic_cut (bool): Apply the cosmic cut?
        Returns:
            tuple(List[ROOT.TH1F], ROOT.TLegend): (List of histograms, Plot legend)
        &#34;&#34;&#34;
        hists = []
        colours = [ROOT.kGreen, ROOT.kBlue, ROOT.kRed, ROOT.kBlack]
        leg = ROOT.TLegend(0.65, 0.65, 0.80, 0.89, &#34;Event Type&#34;)
        entries = [&#34;EL-CC&#34;, &#34;MU-CC&#34;, &#34;NC&#34;, &#34;Cosmic&#34;]
        for i in range(4):
            name = &#34;h_&#34; + parameter + &#34;_&#34; + entries[i]
            hist = ROOT.TH1F(name, parameter, bins, x_low, x_high)
            hist.SetLineColor(colours[i])
            hist.SetLineWidth(2)
            hist.GetXaxis().SetTitle(parameter)

            events = self.events[self.events[&#39;t_full_cat&#39;] == i]

            if base_cut:
                events = events[events.base_cut == 0]
            if cosmic_cut:
                events = events[events.cosmic_cut == 0]

            if scale == &#39;weight&#39;:
                fill_hist(hist, events[parameter].to_numpy(), events[&#39;weight&#39;].to_numpy())
            elif scale == &#39;norm&#39;:
                fill_hist(hist, events[parameter].to_numpy())
                if hist.GetEntries() &gt; 0:
                    hist.Scale(1.0/hist.GetEntries())
            elif scale == &#39;none&#39;:
                fill_hist(hist, events[parameter].to_numpy())
            else:
                raise NotImplementedError
            hists.append(hist)
            leg.AddEntry(hists[i], entries[i], &#34;PL&#34;)

        hists[0].GetYaxis().SetRangeUser(y_low, y_high)

        leg.SetTextSize(0.03)
        leg.SetTextFont(42)
        leg.SetBorderSize(0)

        return hists, leg


class EnergyEvaluator(BaseEvaluator):
    &#34;&#34;&#34;Energy estimation model evaluation.&#34;&#34;&#34;

    def __init__(self, config):
        &#34;&#34;&#34;
        Initialise the CombinedEvaluator.

        Args:
            config (dotmap.DotMap): DotMap Configuration namespace
        &#34;&#34;&#34;
        super().__init__(config)

    def init_evaluator(self):
        &#34;&#34;&#34;
        Initialise the evaluator, setup models and evaluation data.
        &#34;&#34;&#34;
        # Setup all the energy estimation models
        self.nuel_qel_cc_m = self.get_model(&#34;nuel_qel_cc&#34;)
        self.nuel_dis_cc_m = self.get_model(&#34;nuel_dis_cc&#34;)
        self.nuel_res_cc_m = self.get_model(&#34;nuel_res_cc&#34;)
        self.nuel_qel_nc_m = self.get_model(&#34;nuel_qel_nc&#34;)
        self.nuel_dis_nc_m = self.get_model(&#34;nuel_dis_nc&#34;)
        self.nuel_res_nc_m = self.get_model(&#34;nuel_res_nc&#34;)
        self.numu_qel_cc_m = self.get_model(&#34;numu_qel_cc&#34;)
        self.numu_dis_cc_m = self.get_model(&#34;numu_dis_cc&#34;)
        self.numu_res_cc_m = self.get_model(&#34;numu_res_cc&#34;)
        self.numu_qel_nc_m = self.get_model(&#34;numu_qel_nc&#34;)
        self.numu_dis_nc_m = self.get_model(&#34;numu_dis_nc&#34;)
        self.numu_res_nc_m = self.get_model(&#34;numu_res_nc&#34;)

        # Get the test dataset
        data_loader = data.DataLoader(self.config)
        self.data = data_loader.test_data()

    def run(self):
        &#34;&#34;&#34;
        Run the full evaluation.
        &#34;&#34;&#34;
        print(&#39;--- Running Evaluation ---\n&#39;)

        start_time = time.time()  # Time how long it takes

        self.run_inference()  # Get model outputs for test data

        print(&#39;--- Done (took %s seconds) ---\n&#39; % (time.time() - start_time))

    def get_model(self, name):
        &#34;&#34;&#34;
        Get and loads the model from the configuration.

        Args:
            name (str): Saved model name
        Returns:
            chipscnv.models model: Model to use in evaluation
        &#34;&#34;&#34;
        config = self.config
        config.model = self.config.models[name]
        config.exp.experiment_dir = self.config.models[name].dir
        config.exp.name = self.config.models[name].path
        chipscvn.config.setup_dirs(config, False)
        model = utils.get_model(config)
        model.load()
        return model

    def run_inference(self):
        &#34;&#34;&#34;
        Get model outputs for test data.
        &#34;&#34;&#34;
        print(&#39;--- running inference...\n&#39;)

        events = {  # Create empty dict to hold all the event data
            &#39;t_nu&#39;: [], &#39;t_code&#39;: [], &#39;t_cat&#39;: [], &#39;t_cosmic_cat&#39;: [],
            &#39;t_full_cat&#39;: [], &#39;t_nu_nc_cat&#39;: [], &#39;t_nc_cat&#39;: [],
            &#39;t_vtxX&#39;: [], &#39;t_vtxY&#39;: [], &#39;t_vtxZ&#39;: [], &#39;t_vtxT&#39;: [], &#39;t_nuEnergy&#39;: [],
            &#39;t_p_pdgs&#39;: [], &#39;t_p_energies&#39;: [], &#39;t_p_dirTheta&#39;: [], &#39;t_p_dirPhi&#39;: [],
            &#39;r_raw_num_hits&#39;: [], &#39;r_filtered_num_hits&#39;: [], &#39;r_num_hough_rings&#39;: [],
            &#39;r_raw_total_digi_q&#39;: [], &#39;r_filtered_total_digi_q&#39;: [],
            &#39;r_first_ring_height&#39;: [], &#39;r_last_ring_height&#39;: [],
            &#39;r_vtxX&#39;: [], &#39;r_vtxY&#39;: [], &#39;r_vtxZ&#39;: [], &#39;r_vtxT&#39;: [],
            &#39;r_dirTheta&#39;: [], &#39;r_dirPhi&#39;: [],
            &#39;nuel_cc_qel_e&#39;: [], &#39;nuel_cc_dis_e&#39;: [], &#39;nuel_cc_res_e&#39;: [],
            &#39;nuel_nc_qel_e&#39;: [], &#39;nuel_nc_dis_e&#39;: [], &#39;nuel_nc_res_e&#39;: [],
            &#39;numu_cc_qel_e&#39;: [], &#39;numu_cc_dis_e&#39;: [], &#39;numu_cc_res_e&#39;: [],
            &#39;numu_nc_qel_e&#39;: [], &#39;numu_nc_dis_e&#39;: [], &#39;numu_nc_res_e&#39;: []
        }

        images = self.config.data.img_size[2]
        if self.config.data.stack:
            images = 1
        for i in range(images):
            events[(&#39;image_&#39; + str(i))] = []

        for x, y in self.data:  # Run prediction on individual batches
            for name, array in list(x.items()):  # Fill events dict with &#39;inputs&#39;
                if name in events.keys():
                    events[name].extend(array.numpy())

            for name, array in list(y.items()):  # Fill events dict with &#39;labels&#39;
                if name in events.keys():
                    events[name].extend(array.numpy())

            events[&#39;nuel_cc_qel_e&#39;].extend(self.nuel_qel_cc_m.model.predict(x))
            events[&#39;nuel_cc_dis_e&#39;].extend(self.nuel_dis_cc_m.model.predict(x))
            events[&#39;nuel_cc_res_e&#39;].extend(self.nuel_res_cc_m.model.predict(x))
            events[&#39;nuel_nc_qel_e&#39;].extend(self.nuel_qel_nc_m.model.predict(x))
            events[&#39;nuel_nc_dis_e&#39;].extend(self.nuel_dis_nc_m.model.predict(x))
            events[&#39;nuel_nc_res_e&#39;].extend(self.nuel_res_nc_m.model.predict(x))
            events[&#39;numu_cc_qel_e&#39;].extend(self.numu_qel_cc_m.model.predict(x))
            events[&#39;numu_cc_dis_e&#39;].extend(self.numu_dis_cc_m.model.predict(x))
            events[&#39;numu_cc_res_e&#39;].extend(self.numu_res_cc_m.model.predict(x))
            events[&#39;numu_nc_qel_e&#39;].extend(self.numu_qel_nc_m.model.predict(x))
            events[&#39;numu_nc_dis_e&#39;].extend(self.numu_dis_nc_m.model.predict(x))
            events[&#39;numu_nc_res_e&#39;].extend(self.numu_res_nc_m.model.predict(x))

        self.events = pd.DataFrame.from_dict(events)  # Convert dict to pandas dataframe
        self.events = self.events.sample(frac=1).reset_index(drop=True)  # Shuffle the dataframe</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="chipscvn.evaluators.BaseEvaluator"><code class="flex name class">
<span>class <span class="ident">BaseEvaluator</span></span>
<span>(</span><span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>Base evaluator class which all implementations derive from.</p>
<p>Initialise the BasicTrainer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dotmap.DotMap</code></dt>
<dd>DotMap Configuration namespace</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseEvaluator(object):

    &#34;&#34;&#34;
    Base evaluator class which all implementations derive from.
    &#34;&#34;&#34;

    def __init__(self, config):
        &#34;&#34;&#34;
        Initialise the BasicTrainer.

        Args:
            config (dotmap.DotMap): DotMap Configuration namespace
        &#34;&#34;&#34;
        self.config = config
        self.init_evaluator()

    def init_evaluator(self):
        &#34;&#34;&#34;
        Initialise the evaluator, overide in derived evaluator class.
        &#34;&#34;&#34;
        raise NotImplementedError

    def run(self):
        &#34;&#34;&#34;
        Run the evaluator, overide in derived evaluator class.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="chipscvn.evaluators.CombinedEvaluator" href="#chipscvn.evaluators.CombinedEvaluator">CombinedEvaluator</a></li>
<li><a title="chipscvn.evaluators.EnergyEvaluator" href="#chipscvn.evaluators.EnergyEvaluator">EnergyEvaluator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="chipscvn.evaluators.BaseEvaluator.init_evaluator"><code class="name flex">
<span>def <span class="ident">init_evaluator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialise the evaluator, overide in derived evaluator class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_evaluator(self):
    &#34;&#34;&#34;
    Initialise the evaluator, overide in derived evaluator class.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.BaseEvaluator.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the evaluator, overide in derived evaluator class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    Run the evaluator, overide in derived evaluator class.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="chipscvn.evaluators.CombinedEvaluator"><code class="flex name class">
<span>class <span class="ident">CombinedEvaluator</span></span>
<span>(</span><span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>Combined Cosmic and Beam classification model evaluation.</p>
<p>Initialise the CombinedEvaluator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dotmap.DotMap</code></dt>
<dd>DotMap Configuration namespace</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CombinedEvaluator(BaseEvaluator):

    &#34;&#34;&#34;
    Combined Cosmic and Beam classification model evaluation.
    &#34;&#34;&#34;

    def __init__(self, config):
        &#34;&#34;&#34;
        Initialise the CombinedEvaluator.

        Args:
            config (dotmap.DotMap): DotMap Configuration namespace
        &#34;&#34;&#34;
        super().__init__(config)

    def init_evaluator(self):
        &#34;&#34;&#34;
        Initialise the evaluator, setup models and evaluation data.
        &#34;&#34;&#34;
        # Get the cosmic classification model and load the most recent weights
        c_config = self.config
        c_config.model = self.config.models.cosmic
        c_config.exp.experiment_dir = self.config.models.cosmic.dir
        c_config.exp.name = self.config.models.cosmic.path
        chipscvn.config.setup_dirs(c_config, False)
        self.c_model = utils.get_model(c_config)
        self.c_model.load()

        # Get the beam classification model and load the most recent weights
        b_config = self.config
        b_config.model = self.config.models.beam
        b_config.exp.experiment_dir = self.config.models.beam.dir
        b_config.exp.name = self.config.models.beam.path
        chipscvn.config.setup_dirs(b_config, False)
        self.b_model = utils.get_model(b_config)
        self.b_model.load()

        # Get the test dataset
        data_loader = data.DataLoader(self.config)
        self.data = data_loader.test_data()

        # Fully combined category names
        self.comb_cat_names = [&#39;Nuel-CC&#39;, &#39;Numu-CC&#39;, &#39;NC&#39;, &#39;Cosmic&#39;]

    def run(self):
        &#34;&#34;&#34;
        Run the full evaluation.
        &#34;&#34;&#34;
        print(&#39;--- Running Evaluation ---\n&#39;)

        start_time = time.time()  # Time how long it takes

        self.run_inference()  # Get model outputs for test data
        self.parse_outputs()  # Parse the outputs into other quantities
        self.calculate_weights()  # Calculate the weights to apply categorically
        self.calculate_cuts()  # Calculate different cuts to be applied

        print(&#39;--- Done (took %s seconds) ---\n&#39; % (time.time() - start_time))

    def run_inference(self):
        &#34;&#34;&#34;
        Get model outputs for test data.
        &#34;&#34;&#34;
        print(&#39;--- running inference...\n&#39;)

        events = {  # Create empty dict to hold all the event data
            &#39;t_nu&#39;: [], &#39;t_code&#39;: [], &#39;t_cat&#39;: [], &#39;t_cosmic_cat&#39;: [],
            &#39;t_full_cat&#39;: [], &#39;t_nu_nc_cat&#39;: [], &#39;t_nc_cat&#39;: [],
            &#39;t_vtxX&#39;: [], &#39;t_vtxY&#39;: [], &#39;t_vtxZ&#39;: [], &#39;t_vtxT&#39;: [], &#39;t_nuEnergy&#39;: [],
            &#39;t_p_pdgs&#39;: [], &#39;t_p_energies&#39;: [], &#39;t_p_dirTheta&#39;: [], &#39;t_p_dirPhi&#39;: [],
            &#39;r_raw_num_hits&#39;: [], &#39;r_filtered_num_hits&#39;: [], &#39;r_num_hough_rings&#39;: [],
            &#39;r_raw_total_digi_q&#39;: [], &#39;r_filtered_total_digi_q&#39;: [],
            &#39;r_first_ring_height&#39;: [], &#39;r_last_ring_height&#39;: [],
            &#39;r_vtxX&#39;: [], &#39;r_vtxY&#39;: [], &#39;r_vtxZ&#39;: [], &#39;r_vtxT&#39;: [],
            &#39;r_dirTheta&#39;: [], &#39;r_dirPhi&#39;: [],
            &#39;c_out&#39;: [], &#39;b_out&#39;: [], &#39;c_dense&#39;: [], &#39;b_dense&#39;: []
        }

        images = self.config.data.img_size[2]
        if self.config.data.stack:
            images = 1
        for i in range(images):
            events[(&#39;image_&#39; + str(i))] = []

        c_dense_model = Model(  # Model to ouput cosmic model dense layer
            inputs=self.c_model.model.input,
            outputs=self.c_model.model.get_layer(&#39;dense_final&#39;).output
        )

        b_dense_model = Model(  # Model to ouput beam model dense layer
            inputs=self.b_model.model.input,
            outputs=self.b_model.model.get_layer(&#39;dense_final&#39;).output
        )

        for x, y in self.data:  # Run prediction on individual batches
            for name, array in list(x.items()):  # Fill events dict with &#39;inputs&#39;
                if name in events.keys():
                    events[name].extend(array.numpy())

            for name, array in list(y.items()):  # Fill events dict with &#39;labels&#39;
                if name in events.keys():
                    events[name].extend(array.numpy())

            events[&#39;c_out&#39;].extend(self.c_model.model.predict(x))
            events[&#39;b_out&#39;].extend(self.b_model.model.predict(x))
            events[&#39;c_dense&#39;].extend(c_dense_model.predict(x))
            events[&#39;b_dense&#39;].extend(b_dense_model.predict(x))

        self.events = pd.DataFrame.from_dict(events)  # Convert dict to pandas dataframe
        self.events = self.events.sample(frac=1).reset_index(drop=True)  # Shuffle the dataframe

    def parse_outputs(self):
        &#34;&#34;&#34;
        Parse the outputs into other quantities.
        &#34;&#34;&#34;
        print(&#39;--- parsing outputs...\n&#39;)

        # Parse outputs into easier to use pandas columns including combined outputs
        self.events.c_out = self.events.c_out.map(lambda x: x[0])
        for i in range(self.b_model.categories):
            self.events[(&#39;b_out_&#39; + str(i))] = self.events.b_out.map(lambda x: x[i])

        self.events[&#39;scores&#39;] = self.events.apply(self.b_model.combine_outputs, axis=1)
        self.events[&#39;nuel_score&#39;] = self.events.scores.map(lambda x: x[0])
        self.events[&#39;numu_score&#39;] = self.events.scores.map(lambda x: x[1])
        self.events[&#39;nc_score&#39;] = self.events.scores.map(lambda x: x[2])
        self.events.drop(&#39;b_out&#39;, axis=1, inplace=True)
        self.events.drop(&#39;scores&#39;, axis=1, inplace=True)

    def calculate_weights(self):
        &#34;&#34;&#34;
        Calculate the weights to apply categorically.
        &#34;&#34;&#34;
        print(&#39;--- calculating weights...\n&#39;)

        tot_nuel = self.events[(self.events.t_nu == 0) &amp;
                               (self.events.t_cosmic_cat == 0)].shape[0]
        tot_numu = self.events[(self.events.t_nu == 1) &amp;
                               (self.events.t_cosmic_cat == 0)].shape[0]
        tot_cosmic = self.events[self.events.t_cosmic_cat == 1].shape[0]
        print(&#34;Total-&gt; Nuel: {}, Numu: {}, Cosmic: {}\n&#34;.format(tot_nuel, tot_numu, tot_cosmic))

        self.nuel_weight = (1.0/tot_nuel)*(self.config.eval.weights.nuel *
                                           self.config.eval.weights.total)
        self.numu_weight = (1.0/tot_numu)*(self.config.eval.weights.numu *
                                           self.config.eval.weights.total)
        self.cosmic_weight = (1.0/tot_cosmic)*(self.config.eval.weights.cosmic *
                                               self.config.eval.weights.total)

        print(&#39;Weights-&gt; Nuel:{0:.4f}, Numu:{1:.4f}, Cosmic:{2:.4f}\n&#39;.format(
            self.nuel_weight, self.numu_weight, self.cosmic_weight)
        )

        self.events[&#39;weight&#39;] = self.events.apply(self.add_weight, axis=1)

    def add_weight(self, event):
        &#34;&#34;&#34;
        Add the correct weight to each event.

        Args:
            event (dict): Pandas event(row) dict
        Returns:
            float: Weight to use for event
        &#34;&#34;&#34;
        if event.t_nu == 0 and event.t_cosmic_cat == 0:
            return self.nuel_weight
        elif event.t_nu == 1 and event.t_cosmic_cat == 0:
            return self.numu_weight
        elif event.t_cosmic_cat == 1:
            return self.cosmic_weight
        else:
            raise NotImplementedError

    def calculate_cuts(self):
        &#34;&#34;&#34;
        Calculate different cuts to be applied.
        &#34;&#34;&#34;
        print(&#39;--- calculating cuts...\n&#39;)

        self.events[&#39;base_cut&#39;] = self.events.apply(self.base_cut, axis=1)
        self.events[&#39;cosmic_cut&#39;] = self.events.apply(self.cosmic_cut, axis=1)

    def base_cut_summary(self):
        &#34;&#34;&#34;
        Print how each category is affected by the base_cut.
        &#34;&#34;&#34;
        print(&#34;Base Cut Summary...\n&#34;)
        for i in range(4):
            cat_events = self.events[self.events.t_full_cat == i]
            print(&#34;{}-&gt; Total {}, Survived: {}\n&#34;.format(
                self.comb_cat_names[i], cat_events.shape[0],
                cat_events[cat_events[&#39;base_cut&#39;] == 0].shape[0]/cat_events.shape[0]))

    def combined_cut_summary(self):
        &#34;&#34;&#34;
        Print how each category is affected by the base_cut + cosmic_cut.
        &#34;&#34;&#34;
        print(&#34;Base + Cosmic Cut Summary...\n&#34;)
        for i in range(4):
            cat_events = self.events[self.events.t_full_cat == i]
            print(&#34;{}-&gt; Total {}, Survived: {}\n&#34;.format(
                self.comb_cat_names[i], cat_events.shape[0], cat_events[
                    (cat_events.base_cut == 0) &amp;
                    (cat_events.cosmic_cut == 0)].shape[0]/cat_events.shape[0]))

    def base_cut(self, event):
        &#34;&#34;&#34;
        Calculate if the event should be cut due to activity.

        Args:
            event (dict): Pandas event(row) dict
        Returns:
            bool: cut or not?
        &#34;&#34;&#34;
        cut = ((event.r_raw_total_digi_q &lt;= self.config.eval.cuts.q) or
               (event.r_first_ring_height &lt;= self.config.eval.cuts.hough) or
               (event.r_dirTheta &lt;= -self.config.eval.cuts.theta) or
               (event.r_dirTheta &gt;= self.config.eval.cuts.theta) or
               (event.r_dirPhi &lt;= -self.config.eval.cuts.phi) or
               (event.r_dirPhi &gt;= self.config.eval.cuts.phi))
        return cut

    def cosmic_cut(self, event):
        &#34;&#34;&#34;
        Calculate if the event should be cut due to the cosmic network output.

        Args:
            event (dict): Pandas event(row) dict
        Returns:
            bool: cut or not?
        &#34;&#34;&#34;
        return (event.c_out &gt;= self.config.eval.cuts.cosmic)

    def cat_plot(self, parameter, bins, x_low, x_high, y_low, y_high, scale=&#39;norm&#39;,
                 base_cut=True, cosmic_cut=True):
        &#34;&#34;&#34;
        Make the histograms and legend for a parameter, split by true category.

        Args:
            parameter (str): Paramter to plot
            bins (int): How many x-bins to use
            x_low (float): Low x-range
            x_high (float): High x-range
            y_low (float): Low y-range
            y_high (float): High y-range
            scale (str): How to scale the histograms
            base_cut (bool): Apply to the base cut?
            cosmic_cut (bool): Apply the cosmic cut?
        Returns:
            tuple(List[ROOT.TH1F], ROOT.TLegend): (List of histograms, Plot legend)
        &#34;&#34;&#34;
        hists = []
        colours = [ROOT.kGreen, ROOT.kGreen+1, ROOT.kGreen+2, ROOT.kGreen+3,
                   ROOT.kBlue, ROOT.kBlue+1, ROOT.kBlue+2, ROOT.kBlue+3,
                   ROOT.kRed, ROOT.kRed+1, ROOT.kRed+2, ROOT.kRed+3,
                   ROOT.kOrange, ROOT.kOrange+1, ROOT.kOrange+2, ROOT.kOrange+3,
                   ROOT.kBlack]
        leg = ROOT.TLegend(0.65, 0.65, 0.80, 0.89, &#34;Event Type&#34;)
        entries = [&#34;EL-CC-QEL&#34;, &#34;EL-CC-RES&#34;, &#34;EL-CC-DIS&#34;, &#34;EL-CC-COH&#34;,
                   &#34;MU-CC-QEL&#34;, &#34;MU-CC-RES&#34;, &#34;MU-CC-DIS&#34;, &#34;MU-CC-COH&#34;,
                   &#34;EL-NC-QEL&#34;, &#34;EL-NC-RES&#34;, &#34;EL-NC-DIS&#34;, &#34;EL-NC-COH&#34;,
                   &#34;MU-NC-QEL&#34;, &#34;MU-NC-RES&#34;, &#34;MU-NC-DIS&#34;, &#34;MU-NC-COH&#34;,
                   &#34;Cosmic&#34;]
        for i in range(17):
            name = &#34;h_&#34; + parameter + &#34;_&#34; + entries[i]
            hist = ROOT.TH1F(name, parameter, bins, x_low, x_high)
            hist.SetLineColor(colours[i])
            hist.SetLineWidth(2)
            hist.GetXaxis().SetTitle(parameter)

            events = self.events[self.events[&#39;t_cat&#39;] == i]

            if base_cut:
                events = events[events.base_cut == 0]
            if cosmic_cut:
                events = events[events.cosmic_cut == 0]

            if scale == &#39;weight&#39;:
                fill_hist(hist, events[parameter].to_numpy(), events[&#39;weight&#39;].to_numpy())
            elif scale == &#39;norm&#39;:
                fill_hist(hist, events[parameter].to_numpy())
                if hist.GetEntries() &gt; 0:
                    hist.Scale(1.0/hist.GetEntries())
            elif scale == &#39;none&#39;:
                fill_hist(hist, events[parameter].to_numpy())
            else:
                raise NotImplementedError
            hists.append(hist)
            leg.AddEntry(hists[i], entries[i], &#34;PL&#34;)

        hists[0].GetYaxis().SetRangeUser(y_low, y_high)

        leg.SetTextSize(0.03)
        leg.SetTextFont(42)
        leg.SetBorderSize(0)

        return hists, leg

    def combined_cat_plot(self, parameter, bins, x_low, x_high, y_low, y_high, scale=&#39;norm&#39;,
                          base_cut=True, cosmic_cut=True):
        &#34;&#34;&#34;
        Make the histograms and legend for a parameter, split by combined category.

        Args:
            parameter (str): Paramter to plot
            bins (int): How many x-bins to use
            x_low (float): Low x-range
            x_high (float): High x-range
            y_low (float): Low y-range
            y_high (float): High y-range
            scale (str): How to scale the histograms
            base_cut (bool): Apply to the base cut?
            cosmic_cut (bool): Apply the cosmic cut?
        Returns:
            tuple(List[ROOT.TH1F], ROOT.TLegend): (List of histograms, Plot legend)
        &#34;&#34;&#34;
        hists = []
        colours = [ROOT.kGreen, ROOT.kBlue, ROOT.kRed, ROOT.kBlack]
        leg = ROOT.TLegend(0.65, 0.65, 0.80, 0.89, &#34;Event Type&#34;)
        entries = [&#34;EL-CC&#34;, &#34;MU-CC&#34;, &#34;NC&#34;, &#34;Cosmic&#34;]
        for i in range(4):
            name = &#34;h_&#34; + parameter + &#34;_&#34; + entries[i]
            hist = ROOT.TH1F(name, parameter, bins, x_low, x_high)
            hist.SetLineColor(colours[i])
            hist.SetLineWidth(2)
            hist.GetXaxis().SetTitle(parameter)

            events = self.events[self.events[&#39;t_full_cat&#39;] == i]

            if base_cut:
                events = events[events.base_cut == 0]
            if cosmic_cut:
                events = events[events.cosmic_cut == 0]

            if scale == &#39;weight&#39;:
                fill_hist(hist, events[parameter].to_numpy(), events[&#39;weight&#39;].to_numpy())
            elif scale == &#39;norm&#39;:
                fill_hist(hist, events[parameter].to_numpy())
                if hist.GetEntries() &gt; 0:
                    hist.Scale(1.0/hist.GetEntries())
            elif scale == &#39;none&#39;:
                fill_hist(hist, events[parameter].to_numpy())
            else:
                raise NotImplementedError
            hists.append(hist)
            leg.AddEntry(hists[i], entries[i], &#34;PL&#34;)

        hists[0].GetYaxis().SetRangeUser(y_low, y_high)

        leg.SetTextSize(0.03)
        leg.SetTextFont(42)
        leg.SetBorderSize(0)

        return hists, leg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="chipscvn.evaluators.BaseEvaluator" href="#chipscvn.evaluators.BaseEvaluator">BaseEvaluator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="chipscvn.evaluators.CombinedEvaluator.add_weight"><code class="name flex">
<span>def <span class="ident">add_weight</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the correct weight to each event.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>dict</code></dt>
<dd>Pandas event(row) dict</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Weight to use for event</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_weight(self, event):
    &#34;&#34;&#34;
    Add the correct weight to each event.

    Args:
        event (dict): Pandas event(row) dict
    Returns:
        float: Weight to use for event
    &#34;&#34;&#34;
    if event.t_nu == 0 and event.t_cosmic_cat == 0:
        return self.nuel_weight
    elif event.t_nu == 1 and event.t_cosmic_cat == 0:
        return self.numu_weight
    elif event.t_cosmic_cat == 1:
        return self.cosmic_weight
    else:
        raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.CombinedEvaluator.base_cut"><code class="name flex">
<span>def <span class="ident">base_cut</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate if the event should be cut due to activity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>dict</code></dt>
<dd>Pandas event(row) dict</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>cut or not?</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_cut(self, event):
    &#34;&#34;&#34;
    Calculate if the event should be cut due to activity.

    Args:
        event (dict): Pandas event(row) dict
    Returns:
        bool: cut or not?
    &#34;&#34;&#34;
    cut = ((event.r_raw_total_digi_q &lt;= self.config.eval.cuts.q) or
           (event.r_first_ring_height &lt;= self.config.eval.cuts.hough) or
           (event.r_dirTheta &lt;= -self.config.eval.cuts.theta) or
           (event.r_dirTheta &gt;= self.config.eval.cuts.theta) or
           (event.r_dirPhi &lt;= -self.config.eval.cuts.phi) or
           (event.r_dirPhi &gt;= self.config.eval.cuts.phi))
    return cut</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.CombinedEvaluator.base_cut_summary"><code class="name flex">
<span>def <span class="ident">base_cut_summary</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Print how each category is affected by the base_cut.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def base_cut_summary(self):
    &#34;&#34;&#34;
    Print how each category is affected by the base_cut.
    &#34;&#34;&#34;
    print(&#34;Base Cut Summary...\n&#34;)
    for i in range(4):
        cat_events = self.events[self.events.t_full_cat == i]
        print(&#34;{}-&gt; Total {}, Survived: {}\n&#34;.format(
            self.comb_cat_names[i], cat_events.shape[0],
            cat_events[cat_events[&#39;base_cut&#39;] == 0].shape[0]/cat_events.shape[0]))</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.CombinedEvaluator.calculate_cuts"><code class="name flex">
<span>def <span class="ident">calculate_cuts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate different cuts to be applied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_cuts(self):
    &#34;&#34;&#34;
    Calculate different cuts to be applied.
    &#34;&#34;&#34;
    print(&#39;--- calculating cuts...\n&#39;)

    self.events[&#39;base_cut&#39;] = self.events.apply(self.base_cut, axis=1)
    self.events[&#39;cosmic_cut&#39;] = self.events.apply(self.cosmic_cut, axis=1)</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.CombinedEvaluator.calculate_weights"><code class="name flex">
<span>def <span class="ident">calculate_weights</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the weights to apply categorically.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_weights(self):
    &#34;&#34;&#34;
    Calculate the weights to apply categorically.
    &#34;&#34;&#34;
    print(&#39;--- calculating weights...\n&#39;)

    tot_nuel = self.events[(self.events.t_nu == 0) &amp;
                           (self.events.t_cosmic_cat == 0)].shape[0]
    tot_numu = self.events[(self.events.t_nu == 1) &amp;
                           (self.events.t_cosmic_cat == 0)].shape[0]
    tot_cosmic = self.events[self.events.t_cosmic_cat == 1].shape[0]
    print(&#34;Total-&gt; Nuel: {}, Numu: {}, Cosmic: {}\n&#34;.format(tot_nuel, tot_numu, tot_cosmic))

    self.nuel_weight = (1.0/tot_nuel)*(self.config.eval.weights.nuel *
                                       self.config.eval.weights.total)
    self.numu_weight = (1.0/tot_numu)*(self.config.eval.weights.numu *
                                       self.config.eval.weights.total)
    self.cosmic_weight = (1.0/tot_cosmic)*(self.config.eval.weights.cosmic *
                                           self.config.eval.weights.total)

    print(&#39;Weights-&gt; Nuel:{0:.4f}, Numu:{1:.4f}, Cosmic:{2:.4f}\n&#39;.format(
        self.nuel_weight, self.numu_weight, self.cosmic_weight)
    )

    self.events[&#39;weight&#39;] = self.events.apply(self.add_weight, axis=1)</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.CombinedEvaluator.cat_plot"><code class="name flex">
<span>def <span class="ident">cat_plot</span></span>(<span>self, parameter, bins, x_low, x_high, y_low, y_high, scale='norm', base_cut=True, cosmic_cut=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Make the histograms and legend for a parameter, split by true category.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parameter</code></strong> :&ensp;<code>str</code></dt>
<dd>Paramter to plot</dd>
<dt><strong><code>bins</code></strong> :&ensp;<code>int</code></dt>
<dd>How many x-bins to use</dd>
<dt><strong><code>x_low</code></strong> :&ensp;<code>float</code></dt>
<dd>Low x-range</dd>
<dt><strong><code>x_high</code></strong> :&ensp;<code>float</code></dt>
<dd>High x-range</dd>
<dt><strong><code>y_low</code></strong> :&ensp;<code>float</code></dt>
<dd>Low y-range</dd>
<dt><strong><code>y_high</code></strong> :&ensp;<code>float</code></dt>
<dd>High y-range</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>str</code></dt>
<dd>How to scale the histograms</dd>
<dt><strong><code>base_cut</code></strong> :&ensp;<code>bool</code></dt>
<dd>Apply to the base cut?</dd>
<dt><strong><code>cosmic_cut</code></strong> :&ensp;<code>bool</code></dt>
<dd>Apply the cosmic cut?</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple(List[ROOT.TH1F], ROOT.TLegend): (List</code> of <code>histograms, Plot legend)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cat_plot(self, parameter, bins, x_low, x_high, y_low, y_high, scale=&#39;norm&#39;,
             base_cut=True, cosmic_cut=True):
    &#34;&#34;&#34;
    Make the histograms and legend for a parameter, split by true category.

    Args:
        parameter (str): Paramter to plot
        bins (int): How many x-bins to use
        x_low (float): Low x-range
        x_high (float): High x-range
        y_low (float): Low y-range
        y_high (float): High y-range
        scale (str): How to scale the histograms
        base_cut (bool): Apply to the base cut?
        cosmic_cut (bool): Apply the cosmic cut?
    Returns:
        tuple(List[ROOT.TH1F], ROOT.TLegend): (List of histograms, Plot legend)
    &#34;&#34;&#34;
    hists = []
    colours = [ROOT.kGreen, ROOT.kGreen+1, ROOT.kGreen+2, ROOT.kGreen+3,
               ROOT.kBlue, ROOT.kBlue+1, ROOT.kBlue+2, ROOT.kBlue+3,
               ROOT.kRed, ROOT.kRed+1, ROOT.kRed+2, ROOT.kRed+3,
               ROOT.kOrange, ROOT.kOrange+1, ROOT.kOrange+2, ROOT.kOrange+3,
               ROOT.kBlack]
    leg = ROOT.TLegend(0.65, 0.65, 0.80, 0.89, &#34;Event Type&#34;)
    entries = [&#34;EL-CC-QEL&#34;, &#34;EL-CC-RES&#34;, &#34;EL-CC-DIS&#34;, &#34;EL-CC-COH&#34;,
               &#34;MU-CC-QEL&#34;, &#34;MU-CC-RES&#34;, &#34;MU-CC-DIS&#34;, &#34;MU-CC-COH&#34;,
               &#34;EL-NC-QEL&#34;, &#34;EL-NC-RES&#34;, &#34;EL-NC-DIS&#34;, &#34;EL-NC-COH&#34;,
               &#34;MU-NC-QEL&#34;, &#34;MU-NC-RES&#34;, &#34;MU-NC-DIS&#34;, &#34;MU-NC-COH&#34;,
               &#34;Cosmic&#34;]
    for i in range(17):
        name = &#34;h_&#34; + parameter + &#34;_&#34; + entries[i]
        hist = ROOT.TH1F(name, parameter, bins, x_low, x_high)
        hist.SetLineColor(colours[i])
        hist.SetLineWidth(2)
        hist.GetXaxis().SetTitle(parameter)

        events = self.events[self.events[&#39;t_cat&#39;] == i]

        if base_cut:
            events = events[events.base_cut == 0]
        if cosmic_cut:
            events = events[events.cosmic_cut == 0]

        if scale == &#39;weight&#39;:
            fill_hist(hist, events[parameter].to_numpy(), events[&#39;weight&#39;].to_numpy())
        elif scale == &#39;norm&#39;:
            fill_hist(hist, events[parameter].to_numpy())
            if hist.GetEntries() &gt; 0:
                hist.Scale(1.0/hist.GetEntries())
        elif scale == &#39;none&#39;:
            fill_hist(hist, events[parameter].to_numpy())
        else:
            raise NotImplementedError
        hists.append(hist)
        leg.AddEntry(hists[i], entries[i], &#34;PL&#34;)

    hists[0].GetYaxis().SetRangeUser(y_low, y_high)

    leg.SetTextSize(0.03)
    leg.SetTextFont(42)
    leg.SetBorderSize(0)

    return hists, leg</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.CombinedEvaluator.combined_cat_plot"><code class="name flex">
<span>def <span class="ident">combined_cat_plot</span></span>(<span>self, parameter, bins, x_low, x_high, y_low, y_high, scale='norm', base_cut=True, cosmic_cut=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Make the histograms and legend for a parameter, split by combined category.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parameter</code></strong> :&ensp;<code>str</code></dt>
<dd>Paramter to plot</dd>
<dt><strong><code>bins</code></strong> :&ensp;<code>int</code></dt>
<dd>How many x-bins to use</dd>
<dt><strong><code>x_low</code></strong> :&ensp;<code>float</code></dt>
<dd>Low x-range</dd>
<dt><strong><code>x_high</code></strong> :&ensp;<code>float</code></dt>
<dd>High x-range</dd>
<dt><strong><code>y_low</code></strong> :&ensp;<code>float</code></dt>
<dd>Low y-range</dd>
<dt><strong><code>y_high</code></strong> :&ensp;<code>float</code></dt>
<dd>High y-range</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>str</code></dt>
<dd>How to scale the histograms</dd>
<dt><strong><code>base_cut</code></strong> :&ensp;<code>bool</code></dt>
<dd>Apply to the base cut?</dd>
<dt><strong><code>cosmic_cut</code></strong> :&ensp;<code>bool</code></dt>
<dd>Apply the cosmic cut?</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple(List[ROOT.TH1F], ROOT.TLegend): (List</code> of <code>histograms, Plot legend)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combined_cat_plot(self, parameter, bins, x_low, x_high, y_low, y_high, scale=&#39;norm&#39;,
                      base_cut=True, cosmic_cut=True):
    &#34;&#34;&#34;
    Make the histograms and legend for a parameter, split by combined category.

    Args:
        parameter (str): Paramter to plot
        bins (int): How many x-bins to use
        x_low (float): Low x-range
        x_high (float): High x-range
        y_low (float): Low y-range
        y_high (float): High y-range
        scale (str): How to scale the histograms
        base_cut (bool): Apply to the base cut?
        cosmic_cut (bool): Apply the cosmic cut?
    Returns:
        tuple(List[ROOT.TH1F], ROOT.TLegend): (List of histograms, Plot legend)
    &#34;&#34;&#34;
    hists = []
    colours = [ROOT.kGreen, ROOT.kBlue, ROOT.kRed, ROOT.kBlack]
    leg = ROOT.TLegend(0.65, 0.65, 0.80, 0.89, &#34;Event Type&#34;)
    entries = [&#34;EL-CC&#34;, &#34;MU-CC&#34;, &#34;NC&#34;, &#34;Cosmic&#34;]
    for i in range(4):
        name = &#34;h_&#34; + parameter + &#34;_&#34; + entries[i]
        hist = ROOT.TH1F(name, parameter, bins, x_low, x_high)
        hist.SetLineColor(colours[i])
        hist.SetLineWidth(2)
        hist.GetXaxis().SetTitle(parameter)

        events = self.events[self.events[&#39;t_full_cat&#39;] == i]

        if base_cut:
            events = events[events.base_cut == 0]
        if cosmic_cut:
            events = events[events.cosmic_cut == 0]

        if scale == &#39;weight&#39;:
            fill_hist(hist, events[parameter].to_numpy(), events[&#39;weight&#39;].to_numpy())
        elif scale == &#39;norm&#39;:
            fill_hist(hist, events[parameter].to_numpy())
            if hist.GetEntries() &gt; 0:
                hist.Scale(1.0/hist.GetEntries())
        elif scale == &#39;none&#39;:
            fill_hist(hist, events[parameter].to_numpy())
        else:
            raise NotImplementedError
        hists.append(hist)
        leg.AddEntry(hists[i], entries[i], &#34;PL&#34;)

    hists[0].GetYaxis().SetRangeUser(y_low, y_high)

    leg.SetTextSize(0.03)
    leg.SetTextFont(42)
    leg.SetBorderSize(0)

    return hists, leg</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.CombinedEvaluator.combined_cut_summary"><code class="name flex">
<span>def <span class="ident">combined_cut_summary</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Print how each category is affected by the base_cut + cosmic_cut.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combined_cut_summary(self):
    &#34;&#34;&#34;
    Print how each category is affected by the base_cut + cosmic_cut.
    &#34;&#34;&#34;
    print(&#34;Base + Cosmic Cut Summary...\n&#34;)
    for i in range(4):
        cat_events = self.events[self.events.t_full_cat == i]
        print(&#34;{}-&gt; Total {}, Survived: {}\n&#34;.format(
            self.comb_cat_names[i], cat_events.shape[0], cat_events[
                (cat_events.base_cut == 0) &amp;
                (cat_events.cosmic_cut == 0)].shape[0]/cat_events.shape[0]))</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.CombinedEvaluator.cosmic_cut"><code class="name flex">
<span>def <span class="ident">cosmic_cut</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate if the event should be cut due to the cosmic network output.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>dict</code></dt>
<dd>Pandas event(row) dict</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>cut or not?</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cosmic_cut(self, event):
    &#34;&#34;&#34;
    Calculate if the event should be cut due to the cosmic network output.

    Args:
        event (dict): Pandas event(row) dict
    Returns:
        bool: cut or not?
    &#34;&#34;&#34;
    return (event.c_out &gt;= self.config.eval.cuts.cosmic)</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.CombinedEvaluator.init_evaluator"><code class="name flex">
<span>def <span class="ident">init_evaluator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialise the evaluator, setup models and evaluation data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_evaluator(self):
    &#34;&#34;&#34;
    Initialise the evaluator, setup models and evaluation data.
    &#34;&#34;&#34;
    # Get the cosmic classification model and load the most recent weights
    c_config = self.config
    c_config.model = self.config.models.cosmic
    c_config.exp.experiment_dir = self.config.models.cosmic.dir
    c_config.exp.name = self.config.models.cosmic.path
    chipscvn.config.setup_dirs(c_config, False)
    self.c_model = utils.get_model(c_config)
    self.c_model.load()

    # Get the beam classification model and load the most recent weights
    b_config = self.config
    b_config.model = self.config.models.beam
    b_config.exp.experiment_dir = self.config.models.beam.dir
    b_config.exp.name = self.config.models.beam.path
    chipscvn.config.setup_dirs(b_config, False)
    self.b_model = utils.get_model(b_config)
    self.b_model.load()

    # Get the test dataset
    data_loader = data.DataLoader(self.config)
    self.data = data_loader.test_data()

    # Fully combined category names
    self.comb_cat_names = [&#39;Nuel-CC&#39;, &#39;Numu-CC&#39;, &#39;NC&#39;, &#39;Cosmic&#39;]</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.CombinedEvaluator.parse_outputs"><code class="name flex">
<span>def <span class="ident">parse_outputs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the outputs into other quantities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_outputs(self):
    &#34;&#34;&#34;
    Parse the outputs into other quantities.
    &#34;&#34;&#34;
    print(&#39;--- parsing outputs...\n&#39;)

    # Parse outputs into easier to use pandas columns including combined outputs
    self.events.c_out = self.events.c_out.map(lambda x: x[0])
    for i in range(self.b_model.categories):
        self.events[(&#39;b_out_&#39; + str(i))] = self.events.b_out.map(lambda x: x[i])

    self.events[&#39;scores&#39;] = self.events.apply(self.b_model.combine_outputs, axis=1)
    self.events[&#39;nuel_score&#39;] = self.events.scores.map(lambda x: x[0])
    self.events[&#39;numu_score&#39;] = self.events.scores.map(lambda x: x[1])
    self.events[&#39;nc_score&#39;] = self.events.scores.map(lambda x: x[2])
    self.events.drop(&#39;b_out&#39;, axis=1, inplace=True)
    self.events.drop(&#39;scores&#39;, axis=1, inplace=True)</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.CombinedEvaluator.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the full evaluation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    Run the full evaluation.
    &#34;&#34;&#34;
    print(&#39;--- Running Evaluation ---\n&#39;)

    start_time = time.time()  # Time how long it takes

    self.run_inference()  # Get model outputs for test data
    self.parse_outputs()  # Parse the outputs into other quantities
    self.calculate_weights()  # Calculate the weights to apply categorically
    self.calculate_cuts()  # Calculate different cuts to be applied

    print(&#39;--- Done (took %s seconds) ---\n&#39; % (time.time() - start_time))</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.CombinedEvaluator.run_inference"><code class="name flex">
<span>def <span class="ident">run_inference</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get model outputs for test data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_inference(self):
    &#34;&#34;&#34;
    Get model outputs for test data.
    &#34;&#34;&#34;
    print(&#39;--- running inference...\n&#39;)

    events = {  # Create empty dict to hold all the event data
        &#39;t_nu&#39;: [], &#39;t_code&#39;: [], &#39;t_cat&#39;: [], &#39;t_cosmic_cat&#39;: [],
        &#39;t_full_cat&#39;: [], &#39;t_nu_nc_cat&#39;: [], &#39;t_nc_cat&#39;: [],
        &#39;t_vtxX&#39;: [], &#39;t_vtxY&#39;: [], &#39;t_vtxZ&#39;: [], &#39;t_vtxT&#39;: [], &#39;t_nuEnergy&#39;: [],
        &#39;t_p_pdgs&#39;: [], &#39;t_p_energies&#39;: [], &#39;t_p_dirTheta&#39;: [], &#39;t_p_dirPhi&#39;: [],
        &#39;r_raw_num_hits&#39;: [], &#39;r_filtered_num_hits&#39;: [], &#39;r_num_hough_rings&#39;: [],
        &#39;r_raw_total_digi_q&#39;: [], &#39;r_filtered_total_digi_q&#39;: [],
        &#39;r_first_ring_height&#39;: [], &#39;r_last_ring_height&#39;: [],
        &#39;r_vtxX&#39;: [], &#39;r_vtxY&#39;: [], &#39;r_vtxZ&#39;: [], &#39;r_vtxT&#39;: [],
        &#39;r_dirTheta&#39;: [], &#39;r_dirPhi&#39;: [],
        &#39;c_out&#39;: [], &#39;b_out&#39;: [], &#39;c_dense&#39;: [], &#39;b_dense&#39;: []
    }

    images = self.config.data.img_size[2]
    if self.config.data.stack:
        images = 1
    for i in range(images):
        events[(&#39;image_&#39; + str(i))] = []

    c_dense_model = Model(  # Model to ouput cosmic model dense layer
        inputs=self.c_model.model.input,
        outputs=self.c_model.model.get_layer(&#39;dense_final&#39;).output
    )

    b_dense_model = Model(  # Model to ouput beam model dense layer
        inputs=self.b_model.model.input,
        outputs=self.b_model.model.get_layer(&#39;dense_final&#39;).output
    )

    for x, y in self.data:  # Run prediction on individual batches
        for name, array in list(x.items()):  # Fill events dict with &#39;inputs&#39;
            if name in events.keys():
                events[name].extend(array.numpy())

        for name, array in list(y.items()):  # Fill events dict with &#39;labels&#39;
            if name in events.keys():
                events[name].extend(array.numpy())

        events[&#39;c_out&#39;].extend(self.c_model.model.predict(x))
        events[&#39;b_out&#39;].extend(self.b_model.model.predict(x))
        events[&#39;c_dense&#39;].extend(c_dense_model.predict(x))
        events[&#39;b_dense&#39;].extend(b_dense_model.predict(x))

    self.events = pd.DataFrame.from_dict(events)  # Convert dict to pandas dataframe
    self.events = self.events.sample(frac=1).reset_index(drop=True)  # Shuffle the dataframe</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="chipscvn.evaluators.EnergyEvaluator"><code class="flex name class">
<span>class <span class="ident">EnergyEvaluator</span></span>
<span>(</span><span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>Energy estimation model evaluation.</p>
<p>Initialise the CombinedEvaluator.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>dotmap.DotMap</code></dt>
<dd>DotMap Configuration namespace</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnergyEvaluator(BaseEvaluator):
    &#34;&#34;&#34;Energy estimation model evaluation.&#34;&#34;&#34;

    def __init__(self, config):
        &#34;&#34;&#34;
        Initialise the CombinedEvaluator.

        Args:
            config (dotmap.DotMap): DotMap Configuration namespace
        &#34;&#34;&#34;
        super().__init__(config)

    def init_evaluator(self):
        &#34;&#34;&#34;
        Initialise the evaluator, setup models and evaluation data.
        &#34;&#34;&#34;
        # Setup all the energy estimation models
        self.nuel_qel_cc_m = self.get_model(&#34;nuel_qel_cc&#34;)
        self.nuel_dis_cc_m = self.get_model(&#34;nuel_dis_cc&#34;)
        self.nuel_res_cc_m = self.get_model(&#34;nuel_res_cc&#34;)
        self.nuel_qel_nc_m = self.get_model(&#34;nuel_qel_nc&#34;)
        self.nuel_dis_nc_m = self.get_model(&#34;nuel_dis_nc&#34;)
        self.nuel_res_nc_m = self.get_model(&#34;nuel_res_nc&#34;)
        self.numu_qel_cc_m = self.get_model(&#34;numu_qel_cc&#34;)
        self.numu_dis_cc_m = self.get_model(&#34;numu_dis_cc&#34;)
        self.numu_res_cc_m = self.get_model(&#34;numu_res_cc&#34;)
        self.numu_qel_nc_m = self.get_model(&#34;numu_qel_nc&#34;)
        self.numu_dis_nc_m = self.get_model(&#34;numu_dis_nc&#34;)
        self.numu_res_nc_m = self.get_model(&#34;numu_res_nc&#34;)

        # Get the test dataset
        data_loader = data.DataLoader(self.config)
        self.data = data_loader.test_data()

    def run(self):
        &#34;&#34;&#34;
        Run the full evaluation.
        &#34;&#34;&#34;
        print(&#39;--- Running Evaluation ---\n&#39;)

        start_time = time.time()  # Time how long it takes

        self.run_inference()  # Get model outputs for test data

        print(&#39;--- Done (took %s seconds) ---\n&#39; % (time.time() - start_time))

    def get_model(self, name):
        &#34;&#34;&#34;
        Get and loads the model from the configuration.

        Args:
            name (str): Saved model name
        Returns:
            chipscnv.models model: Model to use in evaluation
        &#34;&#34;&#34;
        config = self.config
        config.model = self.config.models[name]
        config.exp.experiment_dir = self.config.models[name].dir
        config.exp.name = self.config.models[name].path
        chipscvn.config.setup_dirs(config, False)
        model = utils.get_model(config)
        model.load()
        return model

    def run_inference(self):
        &#34;&#34;&#34;
        Get model outputs for test data.
        &#34;&#34;&#34;
        print(&#39;--- running inference...\n&#39;)

        events = {  # Create empty dict to hold all the event data
            &#39;t_nu&#39;: [], &#39;t_code&#39;: [], &#39;t_cat&#39;: [], &#39;t_cosmic_cat&#39;: [],
            &#39;t_full_cat&#39;: [], &#39;t_nu_nc_cat&#39;: [], &#39;t_nc_cat&#39;: [],
            &#39;t_vtxX&#39;: [], &#39;t_vtxY&#39;: [], &#39;t_vtxZ&#39;: [], &#39;t_vtxT&#39;: [], &#39;t_nuEnergy&#39;: [],
            &#39;t_p_pdgs&#39;: [], &#39;t_p_energies&#39;: [], &#39;t_p_dirTheta&#39;: [], &#39;t_p_dirPhi&#39;: [],
            &#39;r_raw_num_hits&#39;: [], &#39;r_filtered_num_hits&#39;: [], &#39;r_num_hough_rings&#39;: [],
            &#39;r_raw_total_digi_q&#39;: [], &#39;r_filtered_total_digi_q&#39;: [],
            &#39;r_first_ring_height&#39;: [], &#39;r_last_ring_height&#39;: [],
            &#39;r_vtxX&#39;: [], &#39;r_vtxY&#39;: [], &#39;r_vtxZ&#39;: [], &#39;r_vtxT&#39;: [],
            &#39;r_dirTheta&#39;: [], &#39;r_dirPhi&#39;: [],
            &#39;nuel_cc_qel_e&#39;: [], &#39;nuel_cc_dis_e&#39;: [], &#39;nuel_cc_res_e&#39;: [],
            &#39;nuel_nc_qel_e&#39;: [], &#39;nuel_nc_dis_e&#39;: [], &#39;nuel_nc_res_e&#39;: [],
            &#39;numu_cc_qel_e&#39;: [], &#39;numu_cc_dis_e&#39;: [], &#39;numu_cc_res_e&#39;: [],
            &#39;numu_nc_qel_e&#39;: [], &#39;numu_nc_dis_e&#39;: [], &#39;numu_nc_res_e&#39;: []
        }

        images = self.config.data.img_size[2]
        if self.config.data.stack:
            images = 1
        for i in range(images):
            events[(&#39;image_&#39; + str(i))] = []

        for x, y in self.data:  # Run prediction on individual batches
            for name, array in list(x.items()):  # Fill events dict with &#39;inputs&#39;
                if name in events.keys():
                    events[name].extend(array.numpy())

            for name, array in list(y.items()):  # Fill events dict with &#39;labels&#39;
                if name in events.keys():
                    events[name].extend(array.numpy())

            events[&#39;nuel_cc_qel_e&#39;].extend(self.nuel_qel_cc_m.model.predict(x))
            events[&#39;nuel_cc_dis_e&#39;].extend(self.nuel_dis_cc_m.model.predict(x))
            events[&#39;nuel_cc_res_e&#39;].extend(self.nuel_res_cc_m.model.predict(x))
            events[&#39;nuel_nc_qel_e&#39;].extend(self.nuel_qel_nc_m.model.predict(x))
            events[&#39;nuel_nc_dis_e&#39;].extend(self.nuel_dis_nc_m.model.predict(x))
            events[&#39;nuel_nc_res_e&#39;].extend(self.nuel_res_nc_m.model.predict(x))
            events[&#39;numu_cc_qel_e&#39;].extend(self.numu_qel_cc_m.model.predict(x))
            events[&#39;numu_cc_dis_e&#39;].extend(self.numu_dis_cc_m.model.predict(x))
            events[&#39;numu_cc_res_e&#39;].extend(self.numu_res_cc_m.model.predict(x))
            events[&#39;numu_nc_qel_e&#39;].extend(self.numu_qel_nc_m.model.predict(x))
            events[&#39;numu_nc_dis_e&#39;].extend(self.numu_dis_nc_m.model.predict(x))
            events[&#39;numu_nc_res_e&#39;].extend(self.numu_res_nc_m.model.predict(x))

        self.events = pd.DataFrame.from_dict(events)  # Convert dict to pandas dataframe
        self.events = self.events.sample(frac=1).reset_index(drop=True)  # Shuffle the dataframe</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="chipscvn.evaluators.BaseEvaluator" href="#chipscvn.evaluators.BaseEvaluator">BaseEvaluator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="chipscvn.evaluators.EnergyEvaluator.get_model"><code class="name flex">
<span>def <span class="ident">get_model</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Get and loads the model from the configuration.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Saved model name</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>chipscnv.models model</code></dt>
<dd>Model to use in evaluation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model(self, name):
    &#34;&#34;&#34;
    Get and loads the model from the configuration.

    Args:
        name (str): Saved model name
    Returns:
        chipscnv.models model: Model to use in evaluation
    &#34;&#34;&#34;
    config = self.config
    config.model = self.config.models[name]
    config.exp.experiment_dir = self.config.models[name].dir
    config.exp.name = self.config.models[name].path
    chipscvn.config.setup_dirs(config, False)
    model = utils.get_model(config)
    model.load()
    return model</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.EnergyEvaluator.init_evaluator"><code class="name flex">
<span>def <span class="ident">init_evaluator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialise the evaluator, setup models and evaluation data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_evaluator(self):
    &#34;&#34;&#34;
    Initialise the evaluator, setup models and evaluation data.
    &#34;&#34;&#34;
    # Setup all the energy estimation models
    self.nuel_qel_cc_m = self.get_model(&#34;nuel_qel_cc&#34;)
    self.nuel_dis_cc_m = self.get_model(&#34;nuel_dis_cc&#34;)
    self.nuel_res_cc_m = self.get_model(&#34;nuel_res_cc&#34;)
    self.nuel_qel_nc_m = self.get_model(&#34;nuel_qel_nc&#34;)
    self.nuel_dis_nc_m = self.get_model(&#34;nuel_dis_nc&#34;)
    self.nuel_res_nc_m = self.get_model(&#34;nuel_res_nc&#34;)
    self.numu_qel_cc_m = self.get_model(&#34;numu_qel_cc&#34;)
    self.numu_dis_cc_m = self.get_model(&#34;numu_dis_cc&#34;)
    self.numu_res_cc_m = self.get_model(&#34;numu_res_cc&#34;)
    self.numu_qel_nc_m = self.get_model(&#34;numu_qel_nc&#34;)
    self.numu_dis_nc_m = self.get_model(&#34;numu_dis_nc&#34;)
    self.numu_res_nc_m = self.get_model(&#34;numu_res_nc&#34;)

    # Get the test dataset
    data_loader = data.DataLoader(self.config)
    self.data = data_loader.test_data()</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.EnergyEvaluator.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the full evaluation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
    Run the full evaluation.
    &#34;&#34;&#34;
    print(&#39;--- Running Evaluation ---\n&#39;)

    start_time = time.time()  # Time how long it takes

    self.run_inference()  # Get model outputs for test data

    print(&#39;--- Done (took %s seconds) ---\n&#39; % (time.time() - start_time))</code></pre>
</details>
</dd>
<dt id="chipscvn.evaluators.EnergyEvaluator.run_inference"><code class="name flex">
<span>def <span class="ident">run_inference</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get model outputs for test data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_inference(self):
    &#34;&#34;&#34;
    Get model outputs for test data.
    &#34;&#34;&#34;
    print(&#39;--- running inference...\n&#39;)

    events = {  # Create empty dict to hold all the event data
        &#39;t_nu&#39;: [], &#39;t_code&#39;: [], &#39;t_cat&#39;: [], &#39;t_cosmic_cat&#39;: [],
        &#39;t_full_cat&#39;: [], &#39;t_nu_nc_cat&#39;: [], &#39;t_nc_cat&#39;: [],
        &#39;t_vtxX&#39;: [], &#39;t_vtxY&#39;: [], &#39;t_vtxZ&#39;: [], &#39;t_vtxT&#39;: [], &#39;t_nuEnergy&#39;: [],
        &#39;t_p_pdgs&#39;: [], &#39;t_p_energies&#39;: [], &#39;t_p_dirTheta&#39;: [], &#39;t_p_dirPhi&#39;: [],
        &#39;r_raw_num_hits&#39;: [], &#39;r_filtered_num_hits&#39;: [], &#39;r_num_hough_rings&#39;: [],
        &#39;r_raw_total_digi_q&#39;: [], &#39;r_filtered_total_digi_q&#39;: [],
        &#39;r_first_ring_height&#39;: [], &#39;r_last_ring_height&#39;: [],
        &#39;r_vtxX&#39;: [], &#39;r_vtxY&#39;: [], &#39;r_vtxZ&#39;: [], &#39;r_vtxT&#39;: [],
        &#39;r_dirTheta&#39;: [], &#39;r_dirPhi&#39;: [],
        &#39;nuel_cc_qel_e&#39;: [], &#39;nuel_cc_dis_e&#39;: [], &#39;nuel_cc_res_e&#39;: [],
        &#39;nuel_nc_qel_e&#39;: [], &#39;nuel_nc_dis_e&#39;: [], &#39;nuel_nc_res_e&#39;: [],
        &#39;numu_cc_qel_e&#39;: [], &#39;numu_cc_dis_e&#39;: [], &#39;numu_cc_res_e&#39;: [],
        &#39;numu_nc_qel_e&#39;: [], &#39;numu_nc_dis_e&#39;: [], &#39;numu_nc_res_e&#39;: []
    }

    images = self.config.data.img_size[2]
    if self.config.data.stack:
        images = 1
    for i in range(images):
        events[(&#39;image_&#39; + str(i))] = []

    for x, y in self.data:  # Run prediction on individual batches
        for name, array in list(x.items()):  # Fill events dict with &#39;inputs&#39;
            if name in events.keys():
                events[name].extend(array.numpy())

        for name, array in list(y.items()):  # Fill events dict with &#39;labels&#39;
            if name in events.keys():
                events[name].extend(array.numpy())

        events[&#39;nuel_cc_qel_e&#39;].extend(self.nuel_qel_cc_m.model.predict(x))
        events[&#39;nuel_cc_dis_e&#39;].extend(self.nuel_dis_cc_m.model.predict(x))
        events[&#39;nuel_cc_res_e&#39;].extend(self.nuel_res_cc_m.model.predict(x))
        events[&#39;nuel_nc_qel_e&#39;].extend(self.nuel_qel_nc_m.model.predict(x))
        events[&#39;nuel_nc_dis_e&#39;].extend(self.nuel_dis_nc_m.model.predict(x))
        events[&#39;nuel_nc_res_e&#39;].extend(self.nuel_res_nc_m.model.predict(x))
        events[&#39;numu_cc_qel_e&#39;].extend(self.numu_qel_cc_m.model.predict(x))
        events[&#39;numu_cc_dis_e&#39;].extend(self.numu_dis_cc_m.model.predict(x))
        events[&#39;numu_cc_res_e&#39;].extend(self.numu_res_cc_m.model.predict(x))
        events[&#39;numu_nc_qel_e&#39;].extend(self.numu_qel_nc_m.model.predict(x))
        events[&#39;numu_nc_dis_e&#39;].extend(self.numu_dis_nc_m.model.predict(x))
        events[&#39;numu_nc_res_e&#39;].extend(self.numu_res_nc_m.model.predict(x))

    self.events = pd.DataFrame.from_dict(events)  # Convert dict to pandas dataframe
    self.events = self.events.sample(frac=1).reset_index(drop=True)  # Shuffle the dataframe</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="chipscvn" href="index.html">chipscvn</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="chipscvn.evaluators.BaseEvaluator" href="#chipscvn.evaluators.BaseEvaluator">BaseEvaluator</a></code></h4>
<ul class="">
<li><code><a title="chipscvn.evaluators.BaseEvaluator.init_evaluator" href="#chipscvn.evaluators.BaseEvaluator.init_evaluator">init_evaluator</a></code></li>
<li><code><a title="chipscvn.evaluators.BaseEvaluator.run" href="#chipscvn.evaluators.BaseEvaluator.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="chipscvn.evaluators.CombinedEvaluator" href="#chipscvn.evaluators.CombinedEvaluator">CombinedEvaluator</a></code></h4>
<ul class="">
<li><code><a title="chipscvn.evaluators.CombinedEvaluator.add_weight" href="#chipscvn.evaluators.CombinedEvaluator.add_weight">add_weight</a></code></li>
<li><code><a title="chipscvn.evaluators.CombinedEvaluator.base_cut" href="#chipscvn.evaluators.CombinedEvaluator.base_cut">base_cut</a></code></li>
<li><code><a title="chipscvn.evaluators.CombinedEvaluator.base_cut_summary" href="#chipscvn.evaluators.CombinedEvaluator.base_cut_summary">base_cut_summary</a></code></li>
<li><code><a title="chipscvn.evaluators.CombinedEvaluator.calculate_cuts" href="#chipscvn.evaluators.CombinedEvaluator.calculate_cuts">calculate_cuts</a></code></li>
<li><code><a title="chipscvn.evaluators.CombinedEvaluator.calculate_weights" href="#chipscvn.evaluators.CombinedEvaluator.calculate_weights">calculate_weights</a></code></li>
<li><code><a title="chipscvn.evaluators.CombinedEvaluator.cat_plot" href="#chipscvn.evaluators.CombinedEvaluator.cat_plot">cat_plot</a></code></li>
<li><code><a title="chipscvn.evaluators.CombinedEvaluator.combined_cat_plot" href="#chipscvn.evaluators.CombinedEvaluator.combined_cat_plot">combined_cat_plot</a></code></li>
<li><code><a title="chipscvn.evaluators.CombinedEvaluator.combined_cut_summary" href="#chipscvn.evaluators.CombinedEvaluator.combined_cut_summary">combined_cut_summary</a></code></li>
<li><code><a title="chipscvn.evaluators.CombinedEvaluator.cosmic_cut" href="#chipscvn.evaluators.CombinedEvaluator.cosmic_cut">cosmic_cut</a></code></li>
<li><code><a title="chipscvn.evaluators.CombinedEvaluator.init_evaluator" href="#chipscvn.evaluators.CombinedEvaluator.init_evaluator">init_evaluator</a></code></li>
<li><code><a title="chipscvn.evaluators.CombinedEvaluator.parse_outputs" href="#chipscvn.evaluators.CombinedEvaluator.parse_outputs">parse_outputs</a></code></li>
<li><code><a title="chipscvn.evaluators.CombinedEvaluator.run" href="#chipscvn.evaluators.CombinedEvaluator.run">run</a></code></li>
<li><code><a title="chipscvn.evaluators.CombinedEvaluator.run_inference" href="#chipscvn.evaluators.CombinedEvaluator.run_inference">run_inference</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="chipscvn.evaluators.EnergyEvaluator" href="#chipscvn.evaluators.EnergyEvaluator">EnergyEvaluator</a></code></h4>
<ul class="">
<li><code><a title="chipscvn.evaluators.EnergyEvaluator.get_model" href="#chipscvn.evaluators.EnergyEvaluator.get_model">get_model</a></code></li>
<li><code><a title="chipscvn.evaluators.EnergyEvaluator.init_evaluator" href="#chipscvn.evaluators.EnergyEvaluator.init_evaluator">init_evaluator</a></code></li>
<li><code><a title="chipscvn.evaluators.EnergyEvaluator.run" href="#chipscvn.evaluators.EnergyEvaluator.run">run</a></code></li>
<li><code><a title="chipscvn.evaluators.EnergyEvaluator.run_inference" href="#chipscvn.evaluators.EnergyEvaluator.run_inference">run_inference</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>